## 封装

- 将类的某些信息隐藏在类内部，不允许外部程序直接访问
- 通过该类提供的方法来实现对隐藏信息的操作和访问
- 隐藏对象的信息
- 留出访问的接口

特点：

1. 只能通过规定的方法访问数据
2. 隐藏类的实例细节，方便修改和实现

- 修改属性 设为 private
- 创建 setter/getter 方法 设为 public，用于属性的读写
- 在 setter/getter 方法中加入属性控制语句 对属性值的合法性进行判断

## 包

作用：

- 管理 java 文件
- 解决同名的文件冲突

## 定义包

语法：

- package 包名;
- package com.zhangsan.animal

注意：

1. 必须放在 Java 源文件的第一行
2. 一个 Java 源文件中只能有一个 package 语句
3. 包名全部英文小写
4. 命名方式：域名倒序+模块+功能

## 导入包

语法：

- import 包名.类名;
- 导入包中全部类： import com.zhangsan.\*;
- 导入包中指定的类：import com.zhangsan.animal.Cat;

## 常用系统包

- java.lang  
  包含 java 语言基础的类
- java.util  
  包含语言中各种工具类
- java.io  
  包含输入、输出相关功能的类

## static

1. static+属性 --- 静态属性
2. statuc+方法 --- 静态方法
3. static+类 --- 不存在
4. static+方法的内部变量 --- 不存在
   静态成员随类加载产生，直至类销毁才回收

`static` 是 `Java`中常用的关键字，代表“全局”或者“静态”的意思。关于`static`的特征，可以理解为：方便在没有创建对象的情况下来进行某些操作。通常可用于修饰成员变量和方法，也可以形成静态代码块。
实际应用中，可将需频繁操作、通用型信息设置、公共组件封装等操作设置为“静态”。

### static + 成员变量 vs 成员变量

概念：
- 静态成员：用 static 修饰的成员变量，通常也称为静态成员、静态属性、类成员、全局属性等。
- 非静态成员：没有被 static 修饰的成员变量，也称为叫做非静态成员、实例变量，实例成员，对象成员、对象属性等。

特征：
- 静态成员：
  - 静态成员是属于整个类的，由类所进行维护，仅在类初次加载时会被初始化，在类销毁时回收。
  - 通过该类实例化的所有对象都共享类中静态资源，任一对象中信息的修订都将影响所有对象。
  - 由于静态成员在类加载期间就已经完成初始化，存储在 Java Heap（JDK7.0 之前存储在方法区）中静态存储区，因此优先于对象而存在，可以通过类名和对象名两种方式访问。
- 非静态成员：
  - 非静态成员属于对象独有，每个对象进行实例化时产生各自的成员，随着对象的回收而释放。
  - 对象对各自成员信息的修订不影响其他对象
  - 只能通过对象名访问

应用：
- 可以将频繁调用的公共信息、期望加快运行效率的成员设置为静态。但需注意，由于其生命周期长，即资源占用周期长，要慎用。

### static + 成员方法 vs 成员方法

概念：

- 静态方法：用 static 修饰的成员方法，通常也称为静态方法、类方法、全局方法等。
- 非静态方法：没有被 static 修饰的成员方法，也称为叫做非静态方法、实例方法，对象方法等。
  特征：
- 与静态成员相似，静态方法属于整个类的，由类所进行维护，优先于对象而存在，因此可以通过类名和对象名两种方式访问，也因此在静态方法中无法直接访问同类中的非静态成员。

### static+代码块 vs 代码块

概念：
- 静态代码块:被 static 修饰的，定义在类内部，用{}括起的代码段
- 构造代码块:没有被 static 修饰的，定义在类内部，用{}括起的代码段
- 普通代码块：定义在方法内部，用{}括起的代码段

特征:
- 静态代码块:
  - 只能出现在类内，不允许出现在方法内。
  - 可以出现多次，按顺序在类加载时执行
  - 无论该类实例化多少对象，只执行一次。
- 构造代码块：
  - 可以在类内出现多次，按顺序在每个对象实例化时执行
  - 执行优先级:晚于静态代码块，高于构造方法。
  - 每次执行对象实例化时，均会执行一次。
- 普通代码块:
  - 可以在方法内出现多次，按顺序在方法调用时执行。

应用
- 静态代码块：基于性能优化考量，多适用于需要在项目启动时执行一次的场景，譬如项目资源整体加载
- 构造代码块：多适用于类中每个对象产生时都需要执行的功能封装，与构造方法区别，构造方法是在 new 执行时有选择性的带参或者无参构造，构造代码块则是，在每个对象实例化时都一定会执行
- 普通代码块：适用于方法内进行代码功能分析。

代码块执行顺序
- 无论实例产生多少对象，静态代码块只执行一次
- 构造代码块随实例化过程调用
- 普通代码块随方法调用执行

总结
- 执行优先级
  - 静态代码块>构造代码块>构造方法
  - 执行次数：静态代码块只执行一次，构造代码块，构造法随着对象实例化个数而定
- 不能在静态代码块中直接对非静态成员赋值
- 可以在构造代码块中直接操作静态和非静态成员
- 不能再静态代码块声明静态成员，可以声明局部变量
- 静态代码块中声明的变量，在外部无法进行访问
- 普通代码块在方法内顺序执行，各自作用范围独立
- 方法内定义的局部变量，作用范围为：自定义位置起，至方法结束。在此期间，不允许方法中普通代码块内存在局部变量声明

### 静态方法

1. 可以直接调用同类中的静态成员
2. 不可以直接调用同类中的非静态成员
3. 可以通过实例化对象后，对象调用的方式完成非静态成员调用

### 代码块

1. 通过{ }可以形成代码块
2. 方法内的代码块称为：普通代码块
3. 类内的代码块称为：构造代码块
4. 构造代码块前+static：静态代码块

### 代码块执行顺序

1. 无论实例产生多少对象，静态代码块只执行一次
2. 构造代码块随实例化过程调用
3. 普通代码块随方法调用执行

