# 微前端

## qiankun 的 2 种应用间通信方式

actions 通信及 shared 通信

## 应该如何划分子应用

在开始介绍 `qiankun` 的应用通信之前，我们需要先了解微前端架构如何划分子应用。在微前端架构中，我们应该**_按业务划分出对应的子应用_**，而**_不是通过功能模块划分子应用_**。这么做的原因有两个：

1. 在微前端架构中，子应用并不是一个模块，而是一个独立的应用，我们将子应用按业务划分可以拥有更好的可维护性和解耦性。
2. 子应用应该具备独立运行的能力，应用间频繁的通信会增加应用的复杂度和耦合度。
   　　综上所述，我们应该从业务的角度出发划分各个子应用，尽可能减少应用间的通信，从而简化整个应用，使得我们的微前端架构可以更加灵活可控。

> 补充一下，上面是理想状态，但是理想状态我们很难达到。微前端最核心的点，是可以做到技术栈无关。比如如果你为了做到技术栈无关，想体验不同的技术，那就无所谓了，直接按模块划分即可，因为单独独立的应用，很多公司遇到这种需求也蛮少。我就是为了实践不同技术栈，所以上了微前端。

本次将介绍两种通信方式：

1. 第一种是 `qiankun` 官方提供的通信方式 - `Actions` 通信，适合业务划分清晰，比较简单的微前端应用，一般来说使用第一种方案就可以满足大部分的应用场景需求。
2. 第二种是基于 `redux` 实现的通信方式 - `Shared` 通信，适合需要跟踪通信状态，子应用具备独立运行能力，较为复杂的微前端应用。

## Actions 通信

我们先介绍官方提供的应用间通信方式 - `Actions` 通信，这种通信方式比较适合业务划分清晰，应用间通信较少的微前端应用场景。

1. 通信原理
   `qiankun` 内部提供了 `initGlobalState` 方法用于注册 `MicroAppStateActions` 实例用于通信，该实例有三个方法，分别是:

- setGlobalState：设置 globalState - 设置新的值时，内部将执行 浅检查，如果检查到 globalState 发生改变则触发通知，通知到所有的 观察者 函数。
- onGlobalStateChange：注册 观察者 函数 - 响应 globalState 变化，在 globalState 发生改变时触发该 观察者 函数。
- offGlobalStateChange：取消 观察者 函数 - 该实例不再响应 globalState 变化。

我们来画一张图来帮助大家理解（见下图）
![](https://sunny586.github.io/dist/mark-down/fe-interview/框架/img/原型链.png)
